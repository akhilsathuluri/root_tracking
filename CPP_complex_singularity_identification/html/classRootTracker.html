<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Root Tracking: RootTracker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Root Tracking
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRootTracker-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RootTracker Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="root__tracker_8hh_source.html">root_tracker.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0d29be3a24392b6a864b8e471f23db6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#a0d29be3a24392b6a864b8e471f23db6c">Methods</a> ()</td></tr>
<tr class="separator:a0d29be3a24392b6a864b8e471f23db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb3dcb73ea58ac44ab15d7803de3d5a"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#a6bb3dcb73ea58ac44ab15d7803de3d5a">NRTracker</a> (VectorXd x, VectorXd y, std::function&lt; VectorXd(VectorXd)&gt; f, std::function&lt; MatrixXd(VectorXd)&gt; Jfy, double eps=pow(10, -10))</td></tr>
<tr class="separator:a6bb3dcb73ea58ac44ab15d7803de3d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5d4b8e89ace70cee9c227f033e5a92"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#acc5d4b8e89ace70cee9c227f033e5a92">DMTracker</a> (VectorXd xprev, VectorXd x, VectorXd y, std::function&lt; MatrixXd(VectorXd)&gt; Jfx, std::function&lt; MatrixXd(VectorXd)&gt; Jfy, double eps=0, std::function&lt; VectorXd(VectorXd)&gt; f=NULL)</td></tr>
<tr class="separator:acc5d4b8e89ace70cee9c227f033e5a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13e787a2ef083592f5c8d07ac4d08bc"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#ae13e787a2ef083592f5c8d07ac4d08bc">NNTracker</a> (VectorXd ys, MatrixXd ysols, int index)</td></tr>
<tr class="separator:ae13e787a2ef083592f5c8d07ac4d08bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8762c10ea3a49ae3410fcec863cf08d4"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#a8762c10ea3a49ae3410fcec863cf08d4">trackAllBranches</a> (VectorXd x, MatrixXd y, std::function&lt; VectorXd(VectorXd)&gt; f, std::function&lt; MatrixXd(VectorXd)&gt; Jfy)</td></tr>
<tr class="separator:a8762c10ea3a49ae3410fcec863cf08d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f1227c2436cf1a84a7b8608b683bdd"><td class="memItemLeft" align="right" valign="top">VectorXcd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#a81f1227c2436cf1a84a7b8608b683bdd">NRCTracker</a> (VectorXcd x, VectorXcd y, std::function&lt; VectorXcd(VectorXcd)&gt; f, std::function&lt; MatrixXcd(VectorXcd)&gt; Jfy, double eps=pow(10, -10))</td></tr>
<tr class="separator:a81f1227c2436cf1a84a7b8608b683bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6467ae384a2333b03f7432da49513a0"><td class="memItemLeft" align="right" valign="top">VectorXcd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#aa6467ae384a2333b03f7432da49513a0">DMCTracker</a> (VectorXcd xprev, VectorXcd x, VectorXcd y, std::function&lt; MatrixXcd(VectorXcd)&gt; Jfx, std::function&lt; MatrixXcd(VectorXcd)&gt; Jfy, double eps=0, std::function&lt; VectorXcd(VectorXcd)&gt; f=NULL)</td></tr>
<tr class="separator:aa6467ae384a2333b03f7432da49513a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c068967c8f4403f9a0ec1c703c2be8"><td class="memItemLeft" align="right" valign="top">VectorXcd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#a73c068967c8f4403f9a0ec1c703c2be8">NNCTracker</a> (VectorXcd ys, MatrixXcd ysols, int index)</td></tr>
<tr class="separator:a73c068967c8f4403f9a0ec1c703c2be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b24fe40d4f662b984311365ffd07aa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRootTracker.html#a9b24fe40d4f662b984311365ffd07aa2">SEI</a> (MatrixXd allroots, double alpha, int selectedroot, std::function&lt; VectorXd(double)&gt; <a class="el" href="manipulator_8hh.html#a617dcde540c04aa64274710efb425bb7">computeXfromParam</a>, Ref&lt; VectorXd &gt; alphahist, Ref&lt; MatrixXd &gt; disthist, std::function&lt; VectorXd(VectorXd)&gt; f, std::function&lt; MatrixXd(VectorXd)&gt; Jfy, std::function&lt; VectorXd(double)&gt; <a class="el" href="manipulator_8hh.html#a1c6194cffda1938f04d3178b7f4b3f1a">computeqExtfromParam</a>)</td></tr>
<tr class="separator:a9b24fe40d4f662b984311365ffd07aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classRootTracker.html">RootTracker</a> class consists of implementations of the following:</p><ul>
<li>Newton-Raphson method based tracking or NRTracker</li>
<li>Davidenkos method based tracking or DMTracker</li>
<li><p class="startli">Nearest neighbour based tracking or NNTracker</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd><p class="startdd">See how things change when openMP is enabled with Eigen </p>
<p class="interdd">See how things change when BLAS and LAPACK are used with Eigen </p>
<p class="enddd">Implement an event identification method that can handle or atleast alert when the system moves close to a singularity</p>
</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>modify the paper with a definition of distance as all the individual elements of the vector being within the eps radius ball. So once we define the eps, we take 2 steps, which gives us 4 solution values, i.e. two branches two sols. Then use a multivariable interpolation scheme to interpolate from both sides. Then find their intersection to find the location of singularity. </dd></dl>
</li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa6467ae384a2333b03f7432da49513a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6467ae384a2333b03f7432da49513a0">&#9670;&nbsp;</a></span>DMCTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXcd RootTracker::DMCTracker </td>
          <td>(</td>
          <td class="paramtype">VectorXcd&#160;</td>
          <td class="paramname"><em>xprev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXcd&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXcd&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXcd(VectorXcd)&gt;&#160;</td>
          <td class="paramname"><em>Jfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXcd(VectorXcd)&gt;&#160;</td>
          <td class="paramname"><em>Jfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXcd(VectorXcd)&gt;&#160;</td>
          <td class="paramname"><em>f</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The DMCTracker uses the Davindenkos' integration method to find the solutions satisfied by the constrain equations. </p>

</div>
</div>
<a id="acc5d4b8e89ace70cee9c227f033e5a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5d4b8e89ace70cee9c227f033e5a92">&#9670;&nbsp;</a></span>DMTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd RootTracker::DMTracker </td>
          <td>(</td>
          <td class="paramtype">VectorXd&#160;</td>
          <td class="paramname"><em>xprev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>Jfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>Jfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>f</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The DMTracker uses the Davindenkos' integration method to find the solutions satisfied by the constrain equations. The output is the values of the unknown variables at each tracking step. The problem of tracking is solved as an initial value problem using the first order derivative form of the constraint equations. This function accepts functions as arguments using the <code>C++11</code> style functional library. This method by default uses the Explicit Euler integration scheme and is the only supported scheme currently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xprev</td><td>The set of input/known variables at the previous tracking step </td></tr>
    <tr><td class="paramname">x</td><td>The set of input/known variables at the current tracking step </td></tr>
    <tr><td class="paramname">y</td><td>The set of output/unknown variables at current step </td></tr>
    <tr><td class="paramname">Jfx</td><td>The expression of the Jacobian matrix of f with respect to x, the known variables. Takes in a single argument of type <code>VectorXd</code> consisting y, x and outputs the evaluation of Jfx </td></tr>
    <tr><td class="paramname">Jfy</td><td>The expression of the Jacobian matrix of f with respect to y, the unknown variables. Takes in a single argument of type <code>VectorXd</code> consisting y, x and outputs the evaluation of Jfy. </td></tr>
    <tr><td class="paramname">eps</td><td>The tolerance of <code>drift</code> to which the computed solutions are to satisfy the non-linear equations. If the drift exceeds the given tolerance, a Newton-Raphson (NR) step is used to bring the variables back to the constraint manifold. The default value of <code>eps</code> is set to 0, meaning the NR step correction is <code>off</code> by default. </td></tr>
    <tr><td class="paramname">f</td><td>The set of expressions of the non-linear functions relating x, y. This parameter is only required if <code>eps</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><p class="startdd">Provide support for different integration methods </p>
<p class="interdd">This isnt working. Implement it using prevtheta like in Mathematica rather than using xnext. That should fix it. </p>
<p class="enddd">The same scheme estimating dx as xnext-x is unstable </p>
</dd></dl>

</div>
</div>
<a id="a0d29be3a24392b6a864b8e471f23db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d29be3a24392b6a864b8e471f23db6c">&#9670;&nbsp;</a></span>Methods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RootTracker::Methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The methods function can be called to view names of all the implemented root tracking methods. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Give provision for an FK solver along with root trackers to use when trackers fail. </dd></dl>

</div>
</div>
<a id="a73c068967c8f4403f9a0ec1c703c2be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c068967c8f4403f9a0ec1c703c2be8">&#9670;&nbsp;</a></span>NNCTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXcd RootTracker::NNCTracker </td>
          <td>(</td>
          <td class="paramtype">VectorXcd&#160;</td>
          <td class="paramname"><em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXcd&#160;</td>
          <td class="paramname"><em>ysols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The NNCTracker uses the nearest neighbour method to identify the roots belonging to a required branch. </p>

</div>
</div>
<a id="ae13e787a2ef083592f5c8d07ac4d08bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13e787a2ef083592f5c8d07ac4d08bc">&#9670;&nbsp;</a></span>NNTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd RootTracker::NNTracker </td>
          <td>(</td>
          <td class="paramtype">VectorXd&#160;</td>
          <td class="paramname"><em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>ysols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The NNTracker uses the nearest neighbour method to identify the roots belonging to a required branch. The output is the selected root at each tracking step. This method assumes the existance of a solver method, <code>Solve</code>, which computes all the roots for given input variables, <code>x</code>. The function expects the solutions to be ordered with all the reals together and the variables belonging to S1 together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ys</td><td>The initiation of the known root of the required branch </td></tr>
    <tr><td class="paramname">ysols</td><td>All the solutions obtained by the <code>Solve</code> method used </td></tr>
    <tr><td class="paramname">index</td><td>The index upto which the reals are present.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><p class="startdd">The method currently deals only with variables belonging to R and S1. </p>
<p class="interdd">Treating the Rodriques parameters as locally belonging to R. </p>
<p class="enddd">Add assertions for cols of ys and ysols to be same. </p>
</dd></dl>

</div>
</div>
<a id="a81f1227c2436cf1a84a7b8608b683bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f1227c2436cf1a84a7b8608b683bdd">&#9670;&nbsp;</a></span>NRCTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXcd RootTracker::NRCTracker </td>
          <td>(</td>
          <td class="paramtype">VectorXcd&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXcd&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXcd(VectorXcd)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXcd(VectorXcd)&gt;&#160;</td>
          <td class="paramname"><em>Jfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>pow(10,&#160;-10)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The NRCTracker uses the Newton-Raphson method iteratively to find the solutions satisfied by the constrain equations. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd><p class="startdd">Write overloaded function for saveDate </p>
<p class="interdd">Write overloaded function for eta and J </p>
<p class="enddd">Make the tracker itself overloaded </p>
</dd></dl>

</div>
</div>
<a id="a6bb3dcb73ea58ac44ab15d7803de3d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb3dcb73ea58ac44ab15d7803de3d5a">&#9670;&nbsp;</a></span>NRTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd RootTracker::NRTracker </td>
          <td>(</td>
          <td class="paramtype">VectorXd&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>Jfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>pow(10,&#160;-10)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The NRTracker uses the Newton-Raphson method iteratively to find the solutions satisfied by the constrain equations. The output is the values of the unknown variables at each tracking step. This function accepts functions as arguments using the <code>C++11</code> style functional library. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The set of input/known variables at current tracking step </td></tr>
    <tr><td class="paramname">y</td><td>The set of output/unknown variables at current step </td></tr>
    <tr><td class="paramname">f</td><td>The set of expressions of the non-linear functions relating x, y. Takes in a single argument of type <code>VectorXd</code> consisting y, x and outputs the evaluation of f. </td></tr>
    <tr><td class="paramname">Jfy</td><td>The expression of the Jacobian matrix of f with respect to y, the unknown variables. Takes in a single argument of type <code>VectorXd</code> consisting y, x and outputs the evaluation of Jfy. </td></tr>
    <tr><td class="paramname">eps</td><td>The required tolerance to which the computed solutions are to satisfy the non-linear equations. Default value is set to 10^-10 </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd><p class="startdd">Decide to return q or y in the NRTracker method </p>
<p class="interdd">fval returning nan is not being handled in the while loop </p>
<p class="enddd">Input argument format and other relevant checks </p>
</dd></dl>

</div>
</div>
<a id="a9b24fe40d4f662b984311365ffd07aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b24fe40d4f662b984311365ffd07aa2">&#9670;&nbsp;</a></span>SEI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RootTracker::SEI </td>
          <td>(</td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>allroots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>selectedroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXd(double)&gt;&#160;</td>
          <td class="paramname"><em>computeXfromParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ref&lt; VectorXd &gt;&#160;</td>
          <td class="paramname"><em>alphahist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ref&lt; MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>disthist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>Jfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXd(double)&gt;&#160;</td>
          <td class="paramname"><em>computeqExtfromParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SEI uses the distance between different branches of the solutions to identify and estimate the singular configuration of the given set of non-linear equations. Further, it uses a quadratic extrapolation scheme to estimate the singular configuration. This function needs the computation of all the roots (currently handles only real roots).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allroots</td><td>Solutions of all the branches of the non-linear equations </td></tr>
    <tr><td class="paramname">alpha</td><td>Parameter value </td></tr>
    <tr><td class="paramname">selectedroot</td><td>The index of the selected branch (Use index starting with 1) </td></tr>
    <tr><td class="paramname">computeXfromParam</td><td>Compute the values of the input variables based on the path parametrisation </td></tr>
    <tr><td class="paramname">alphahist</td><td>Input vector (global to main) to store history of alphas for estimating the singular configuration </td></tr>
    <tr><td class="paramname">disthist</td><td>Input vector (global to main) to store history of distances for estimating the singular configuration </td></tr>
    <tr><td class="paramname">f</td><td>Set of non-linear equations </td></tr>
    <tr><td class="paramname">Jft</td><td>Jacobian matrix of the set of equations </td></tr>
    <tr><td class="paramname">computeqExtfromParam</td><td>Function which produces the extended configuration values given the path parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd><p class="startdd">Optionally Bertini can be used to compute all the roots. Note that the method is limited to single parameter paths. </p>
<p class="interdd">Check the alpha selection with Aditya </p>
<p class="enddd">Assumes a quadratic interpolation, but can be made to accept an nth degree polynomial </p>
</dd></dl>

</div>
</div>
<a id="a8762c10ea3a49ae3410fcec863cf08d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8762c10ea3a49ae3410fcec863cf08d4">&#9670;&nbsp;</a></span>trackAllBranches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd RootTracker::trackAllBranches </td>
          <td>(</td>
          <td class="paramtype">VectorXd&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; VectorXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; MatrixXd(VectorXd)&gt;&#160;</td>
          <td class="paramname"><em>Jfy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The trackAllBranches routine tracks one step in all the branches given the next steps input variable and an initial guess of the unknown variables using the relating function f and its Jacobian Jfy. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="root__tracker_8hh_source.html">root_tracker.hh</a></li>
<li><a class="el" href="root__tracker_8cc.html">root_tracker.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
